
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<h2>FormLister: Валидация данных</h2>

<p>При валидации данных валидатор последовательно применяет к значению поля заданные правила, при возникновении ошибки в массив данных об ошибках добавляется запись и дальнейшая обработка формы прекращается.</p>
<p>Валидация считается пройденной, если в массиве данных об ошибках отсутствуют записи. </p>
<h3 class="sub-header text-bold">Правила валидации</h3>
<p>Список правил задается в виде массива. Ключом является имя поля, а значением - массив правил валидации. Правило валидации является методом класса-валидатора. В массиве правил ключом является имя правила (название метода валидации), значением может быть либо строка с сообщением об ошибке валидации правила, или же массив с описанием. В этом массиве в ключе params задаются необходимые для валидации значения, а в ключе message задается строка с сообщением об ошибке.</p>
<p>Можно также использовать отрицание правил, если добавить перед именем правила восклицательный знак: "!numeric" - поле пройдет валидацию, если его значение не является числом.</p>
<p>Если нужно реализовать проверку только заполненных полей, то перед именем поля в списке правил нужно добавить восклицательный знак. В этом случае если значение поля пустое, правила будут проигнорированы.</p>
<pre class="brush: html;">{
    "имя поля 1": {
        "правило 1" : "сообщение об ошибке",
        "правило 2" : "сообщение об ошибке"
    },
    "имя поля 2": {
        "правило 1" : "сообщение об ошибке",
        "правило 2" : {
            "params" : значение,
            "message" : "сообщение об ошибке"
        }
    },
    "!имя поля 3":{
        "правило 1" : "сообщение об ошибке"
    }
}</pre>
<p>Стандартным классом валидации (\FormLister\Validator) предусмотрены правила:</p>
<ul>
<li>required: поле заполнено;</li>
<li>date: значение поля является датой в заданном формате;</li>
<li>min: значение поля больше заданного или равно ему;</li>
<li>max: значение поля меньше заданного или равно ему;</li>
<li>greater: значение поля строго меньше заданного;</li>
<li>less: значение поля строго больше заданного;</li>
<li>between: значение поля входит в диапазон;</li>
<li>equals: значение поля равно заданному;</li>
<li>in: значение поля входит в заданный массив значений;</li>
<li>alpha: значение поля содержит только буквы;</li>
<li>numeric: значение поля содержит только цифры;</li>
<li>alphaNumeric: значение поля содержит только буквы и цифры;</li>
<li>slug: значение поля является частью url;</li>
<li>decimal: значение поля является десятичным числом;</li>
<li>phone: значение поля является номером телефона;</li>
<li>matches: значение поля удовлетворяет регулярному выражению;</li>
<li>url: значение поля является ссылкой;</li>
<li>email: значение поля является email-адресом;</li>
<li>length: длина значения поля равна заданному;</li>
<li>minLength: длина значения поля больше заданного или равна ему;</li>
<li>maxLength: длина значения поля меньше заданного или равна ему;</li>
<li>lengthBetween: длина значения поля входит в диапазон;</li>
<li>minCount: размер массива больше заданного;</li>
<li>maxCount: размер массива меньше заданного;</li>
<li>countBetween: размер массива входит в диапазон.</li>
</ul>
<p>Если требуется задать два значения для правила, то их следует задавать как массив:</p>
<pre class="brush: html;">&amp;rules=`{
    "field" : {
        "lengthBetween" : {
            "params" : [10,20],
            "message" : "Длина должна быть от 10 до 20"
        }
    }
}`</pre>
<p>Для правила in (и других правил, использующих массив) массив значений следует задавать следующим образом:</p>
<pre class="brush: html;">&amp;rules=`{
    "field" : {
        "in" : {
            "params" : [ [10,20,30] ],
            "message" : "Значение поля field должно быть равно 10, 20 или 30"
        }
    }
}`</pre>
<p>Это нужно, чтобы массив был передан в функцию одним аргументом.</p>
<p>Предусмотрена также возможность использовать для валидации функции или статические методы загруженного класса:</p>
<pre class="brush: html;">&amp;rules=`{
    "myfield":{
        "required":"Required field",
        "custom":{
            "function":"\\Namespace\\Classname::myCustomRule",
            "params":[10,20,30],
            "message":"Custom check failed"
        }
    }
}`</pre>
<p>Метод должен принимать первым аргументом экземпляр контроллера из которого вызывается правило, вторым аргументом - значение проверяемого поля, далее - параметры передаваемые в ключе описания params:</p>
<pre class="brush: html;">public static function myCustomRule($fl,$value,$a,$b,$c) {
    $result = $fl-&gt;getField('field1') == $a &amp;&amp; $fl-&gt;getField('field2') == $b &amp;&amp; $value == $c;
    return $result;
}</pre>
<p>В примере правило будет пройдено, если значение поля field1 = 10, значение поля field2 = 20, а значение поля, к которму применяется правило, = 30.</p>
<p>Метод должен вернуть true, false или текст сообщения об ошибке (в этом случае можно не указывать message в списке правил).</p>
<p>В примере используется название правила "сustom", но можно использовать любое название правила, которого нет в классе валидации. Таким образом можно использовать несколько правил данного типа.</p>
<h3 class="sub-header text-bold">Результаты валидации</h3>
<p>Данные об ошибках хранятся в виде массива и могут быть получены вызовом метода getFormData('errors'):</p>
<pre class="brush: html;">{
    "имя поля 1": {
        "имя нарушенного правила" : "сообщение об ошибке"
    },
    "имя поля 2": {
        "имя нарушенного правила" : "сообщение об ошибке"
    }
}</pre>
<p>Для добавления данных в этот массив используется метод addError(имя поля, имя правила, сообщение об ошибке). Таким образом, можно влиять на итоговый результат валидации, вручную добавляя записи в этот массив. Можно также объявить валидацию непройденной по умолчанию, вызвав метод setValid(false). </p>
<p>В шаблонах результаты валидации для каждого поля выводятся с помощью плейсхолдера [+имя поля.error+]. Общий результат может быть выведен в плейсхолдер [+form.messages+], который задается шаблоном messagesTpl. В свою очередь, в этом шаблоне можно использовать плейсхолдеры: </p>
<ul>
<li>[+required+] - сообщения о незаполенных полях;</li>
<li>[+errors+] - сообщения о неверно заполненных полях.</li>
</ul>
<p>Получить сообщения об ошибках для определенного поля можно с помощью метода getErrorMessage(имя поля).</p>